#### 1 算法分析相关概念
1. 时间复杂度：算法执行所需的时间与问题规模之间的关系。

2. 空间复杂度：算法执行所需的空间与问题规模之间的关系。

3. 最优时间复杂度：算法在最理想情况下所需的时间复杂度。

4. 最坏时间复杂度：算法在最不利情况下所需的时间复杂度。

5. 平均时间复杂度：算法在所有情况下所需的时间复杂度的平均值。

6. 渐进时间复杂度：算法在问题规模趋近于无穷大时所需的时间复杂度。

7. 渐进空间复杂度：算法在问题规模趋近于无穷大时所需的空间复杂度。

8. 稳定性：排序算法中，如果两个相等的元素在排序前后的相对位置不变，则称该算法是稳定的。

9. 内部排序：排序算法中，所有数据都在内存中进行排序的算法。

10. 外部排序：排序算法中，数据量太大无法全部存放在内存中，需要借助外部存储器进行排序的算法。




#### 2 素数判定相关定理
1. 费马小定理：如果p是一个素数，a是不被p整除的整数，那么a^(p-1) ≡ 1 (mod p)。

2. 欧拉定理：如果a和n是互质的正整数，那么a^φ(n) ≡ 1 (mod n)，其中φ(n)表示小于等于n的正整数中与n互质的数的个数。

3. 米勒-拉宾定理：如果p是一个素数，a是不被p整除的整数，那么如果存在一个整数k，使得(p-1)能够表示成2^t * k的形式，且a^k ≡ 1 (mod p) 或者存在一个整数i满足0≤i≤t-1，使得a^(2^i * k) ≡ -1 (mod p)，那么a就是p的一个“伪素数”，否则a就是p的一个合数。

4. 素性检验定理：如果n是一个大于2的整数，那么如果n不是素数，那么n的最小质因子一定小于等于√n。因此，我们只需要在2到√n之间枚举所有的数，判断n是否能够被整除即可。



#### 3 P,NP,NPC,NP-hard相关概念以及经典问题
P：P问题是指可以在多项式时间内解决的问题，即可以在多项式时间内找到问题的解。

NP：NP问题是指可以在多项式时间内验证问题的解是否正确，但不能在多项式时间内找到问题的解。NP问题是一类非常重要的问题，因为许多实际问题都属于NP问题。

NPC：NPC问题是指既属于NP问题，又是NP问题中最难的问题。如果一个问题是NPC问题，那么它可以被归约到任何其他NP问题，也就是说，如果我们能够在多项式时间内解决一个NPC问题，那么我们就能够在多项式时间内解决所有的NP问题。

NP-hard：NP-hard问题是指可以被归约到任何NP问题的问题。NP-hard问题不一定是NP问题，但是它们都是非常困难的问题。

经典问题：

1.旅行商问题（TSP）：给定一组城市和它们之间的距离，找到一条经过每个城市一次且回到起点的最短路径。

2.背包问题（KP）：给定一组物品和它们的价值和重量，以及一个背包的容量，找到一种最优的方式将物品放入背包中，使得背包中物品的总价值最大。

3.图着色问题（GC）：给定一个无向图，找到一种最小的方式将图中的每个节点着色，使得相邻的节点颜色不同。

4.最大独立集问题（MIS）：给定一个无向图，找到一个最大的节点集合，使得集合中的任意两个节点之间没有边相连。

5.最长公共子序列问题（LCS）：给定两个字符串，找到它们之间最长的公共子序列。


#### 4 分治算法相关概念
1. 分治算法：将一个大问题分解成若干个小问题，分别解决后再将结果合并起来得到最终解的算法。

2. 递归：在算法中调用自身的过程，可以将一个大问题分解成若干个小问题。

3. 分解：将一个大问题分解成若干个小问题，通常是将问题划分成相同规模的子问题。

4. 解决：对每个子问题进行求解，通常是通过递归调用算法本身来解决。

5. 合并：将子问题的解合并成原问题的解，通常是通过合并排序、合并查找等方式来实现。

6. 最优子结构：一个问题的最优解包含其子问题的最优解，即问题的最优解可以通过子问题的最优解来推导得到。

7. 重叠子问题：在分治算法中，子问题之间可能存在重叠，即某些子问题可能会被重复求解，这时可以使用记忆化搜索等技术来避免重复计算。

8. 时间复杂度：分治算法的时间复杂度通常为O(nlogn)，其中n为问题规模。

#### 5 贪心算法相关概念
1. 贪心策略：贪心算法的核心思想，即每一步都选择当前最优解，以期达到全局最优解。

2. 最优子结构：问题的最优解可以由子问题的最优解推导出来。

3. 可行解：满足问题约束条件的解。

4. 最优解：在所有可行解中，满足问题目标函数最大或最小的解。

5. 贪心选择性质：每一步选择最优解，不考虑未来的影响。

6. 局部最优解：在当前状态下，选择最优解。

7. 全局最优解：在所有状态下，选择最优解。

8. 贪心算法的适用性：贪心算法适用于满足贪心选择性质和最优子结构的问题。

#### 6 动态规划算法相关概念
1. 最优子结构：问题的最优解可以由子问题的最优解推导出来。

2. 重叠子问题：在求解问题的过程中，会出现重复的子问题。

3. 状态转移方程：描述子问题之间的关系，用于计算当前问题的最优解。

4. 边界条件：问题的最小规模情况下的解。

5. 自底向上求解：从边界条件开始，逐步计算出更大规模的问题的最优解。

6. 记忆化搜索：自顶向下求解，将已经计算过的子问题的解保存下来，避免重复计算。

7. 动态规划算法的适用性：适用于满足最优子结构和重叠子问题的问题。


#### 7 回溯,分支限界法相关概念
回溯算法相关概念：

1. 状态空间树：将问题的所有可能解构成一棵树，树的每个节点表示问题的一个状态，树的边表示状态之间的转移。

2. 回溯：在搜索状态空间树的过程中，当发现当前状态不满足问题的约束条件时，回退到上一个状态，重新搜索。

3. 剪枝：在搜索状态空间树的过程中，当发现当前状态不可能得到最优解时，剪去该状态的子树，减少搜索时间。

4. 可行解：满足问题约束条件的解。

5. 最优解：在所有可行解中，满足问题目标函数最大或最小的解。

分支限界法相关概念：

1. 分支：将当前状态扩展成多个子状态。

2. 限界：通过计算当前状态的下界或上界，剪去不可能得到最优解的子树。

3. 优先队列：用于存储待扩展的状态，按照优先级排序，每次扩展优先级最高的状态。

4. 可行解：满足问题约束条件的解。

5. 最优解：在所有可行解中，满足问题目标函数最大或最小的解。

6. 分支限界算法的适用性：适用于满足最优子结构的问题，且问题的状态空间树可以被分解成多个子树。



#### 8 随机算法相关概念
随机算法相关概念：

1. 随机性：随机算法的核心思想是引入随机性，使得算法的结果具有一定的概率性。

2. 概率分析：随机算法的正确性通常是基于概率分析的，即算法的正确性是以一定概率发生的。

3. 蒙特卡罗算法：一种基于随机抽样的算法，通过对样本的统计分析来估计问题的解。

4. 拉斯维加斯算法：一种基于随机化的确定性算法，算法的正确性是绝对的，但是算法的运行时间是随机的。

5. 随机化算法的适用性：适用于那些问题的解难以用确定性算法求解，但是可以通过引入随机性来得到近似解的问题。


#### 9 最小生成树构造算法及相关概念
最小生成树是指在一个加权连通图中，找到一棵生成树，使得所有边的权值之和最小。最小生成树构造算法有以下几种：

1. Prim算法：从一个顶点开始，每次选择一个与当前生成树相邻的最小权值边所连接的顶点，直到所有顶点都被加入生成树。

2. Kruskal算法：将所有边按照权值从小到大排序，依次加入生成树，如果加入的边会形成环，则不加入。

3. Boruvka算法：将所有顶点看作一个连通块，每次选择每个连通块的最小权值边，将连通块合并，直到只剩下一个连通块。

相关概念：

1. 加权连通图：每条边都有一个权值的连通图。

2. 生成树：一个连通图的生成树是指一个包含所有顶点的树，它是原图的一个子图，且是一棵树。

3. 最小生成树：在一个加权连通图中，找到一棵生成树，使得所有边的权值之和最小。

4. 贪心算法：每次选择当前最优解，不考虑未来的影响。最小生成树算法就是一种贪心算法。


#### 10 排序问题求解: 快速排序,归并排序
快速排序和归并排序都是常用的排序算法，它们的时间复杂度都为O(nlogn)。

快速排序：

快速排序是一种分治算法，它的基本思想是选择一个基准元素，将数组分成两个子数组，小于基准元素的放在左边，大于基准元素的放在右边，然后对左右两个子数组分别进行快速排序，直到整个数组有序。

具体实现步骤如下：

1. 选择一个基准元素，一般选择第一个元素或者最后一个元素。

2. 将数组分成两个子数组，小于基准元素的放在左边，大于基准元素的放在右边。

3. 对左右两个子数组分别进行快速排序，直到整个数组有序。

归并排序：

归并排序也是一种分治算法，它的基本思想是将数组分成两个子数组，分别进行排序，然后将两个有序子数组合并成一个有序数组。

具体实现步骤如下：

1. 将数组分成两个子数组，分别进行排序。

2. 将两个有序子数组合并成一个有序数组。

3. 重复以上步骤，直到整个数组有序。

快速排序和归并排序的比较：

1. 快速排序的平均时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2)，而归并排序的时间复杂度始终为O(nlogn)。

2. 快速排序是一种原地排序算法，不需要额外的存储空间，而归并排序需要额外的存储空间。

3. 快速排序是一种不稳定的排序算法，而归并排序是一种稳定的排序算法。

4. 在实际应用中，快速排序的效率通常比归并排序高，因为它的常数因子比较小。



#### 11 单源最短路径问题求解:Dijkstra,Bellman-Ford,分支限界
Dijkstra算法：

Dijkstra算法是一种贪心算法，用于解决单源最短路径问题。它的基本思想是从起点开始，每次选择当前距离起点最近的一个顶点，然后更新与该顶点相邻的顶点的距离。具体实现时，可以使用一个优先队列来维护当前距离起点最近的顶点。

Dijkstra算法的时间复杂度为O(ElogV)，其中E为边数，V为顶点数。

Bellman-Ford算法：

Bellman-Ford算法是一种动态规划算法，用于解决单源最短路径问题。它的基本思想是通过对所有边进行V-1轮松弛操作，来逐步缩小起点到各个顶点的距离。如果在第V轮松弛操作后仍然存在可以更新的距离，则说明存在负权环。

Bellman-Ford算法的时间复杂度为O(VE)，其中E为边数，V为顶点数。

分支限界算法：

分支限界算法是一种搜索算法，用于解决最优化问题。它的基本思想是通过对问题的解空间进行搜索，每次选择一个可行解进行扩展，直到找到最优解或者无法继续扩展为止。在搜索过程中，通过剪枝操作来减少搜索空间，提高搜索效率。

对于单源最短路径问题，可以使用分支限界算法来求解。具体实现时，可以将问题转化为一个状态空间树，每个节点表示一个路径，每次选择一个节点进行扩展，直到找到最短路径为止。在扩展节点时，可以根据当前路径长度和剩余未访问的顶点来计算一个下界，用于剪枝。

分支限界算法的时间复杂度取决于搜索空间的大小，通常情况下比Dijkstra和Bellman-Ford算法更慢，但在某些特殊情况下可能会更快。


#### 12 回溯/分支限界法:0-1背包求解分析,N后问题求解分析
0-1背包问题求解分析：

0-1背包问题是一个经典的背包问题，给定一个背包容量和一组物品，每个物品有一个重量和一个价值，要求在不超过背包容量的前提下，选择一些物品放入背包，使得背包中物品的总价值最大。

回溯算法可以用来解决0-1背包问题。具体实现时，可以将问题转化为一个状态空间树，每个节点表示一个物品的选择情况，每次选择一个物品进行扩展，直到所有物品都被考虑过为止。在扩展节点时，可以根据当前背包容量和剩余未考虑的物品来计算一个上界，用于剪枝。

分支限界算法也可以用来解决0-1背包问题。具体实现时，可以将问题转化为一个状态空间树，每个节点表示一个物品的选择情况，每次选择一个物品进行扩展，直到所有物品都被考虑过为止。在扩展节点时，可以根据当前背包价值和剩余未考虑的物品来计算一个下界，用于剪枝。

N后问题求解分析：

N后问题是一个经典的八皇后问题，给定一个N*N的棋盘，要求在上面放置N个皇后，使得它们互相不攻击。皇后可以攻击同一行、同一列和同一对角线上的其他棋子。

回溯算法可以用来解决N后问题。具体实现时，可以将问题转化为一个状态空间树，每个节点表示一个皇后的位置，每次选择一个位置进行扩展，直到所有皇后都被放置为止。在扩展节点时，可以根据当前皇后的位置和已经放置的皇后来计算一个上界，用于剪枝。

分支限界算法也可以用来解决N后问题。具体实现时，可以将问题转化为一个状态空间树，每个节点表示一个皇后的位置，每次选择一个位置进行扩展，直到所有皇后都被放置为止。在扩展节点时，可以根据当前皇后的位置和已经放置的皇后来计算一个下界，用于剪枝。

#### 13 增广路算法: 最大流求解分析
增广路算法是一种用于求解最大流问题的经典算法。该算法的基本思想是在残留网络中寻找一条增广路，将该路上的流量增加到当前流量中，直到无法找到增广路为止。下面对增广路算法进行详细的分析。

1. 残留网络

在增广路算法中，我们需要维护一个残留网络，该网络表示当前流量与最大流量之间的差异。具体来说，对于一条边(u, v)，其残留容量r(u, v)定义为：

r(u, v) = c(u, v) - f(u, v)

其中，c(u, v)表示边(u, v)的容量，f(u, v)表示边(u, v)上的流量。如果f(u, v) < c(u, v)，则残留容量r(u, v)为正数，表示还可以增加流量；如果f(u, v) > 0，则残留容量r(u, v)为负数，表示可以减少流量。

2. 增广路

在残留网络中，从源点s到汇点t的一条路径称为增广路。增广路上的流量可以增加到当前流量中，从而得到一个更大的流量。在增广路算法中，我们需要寻找一条增广路，并将其上的流量增加到当前流量中。

3. Ford-Fulkerson算法

增广路算法的基本思想可以追溯到Ford-Fulkerson算法。该算法的基本思想是不断寻找增广路，并将其上的流量增加到当前流量中，直到无法找到增广路为止。具体来说，Ford-Fulkerson算法包括以下步骤：

（1）初始化流量f(u, v)为0；

（2）在残留网络中寻找一条增广路；

（3）如果找到增广路，则将其上的流量增加到当前流量中；

（4）重复步骤（2）和（3），直到无法找到增广路为止。

4. Edmonds-Karp算法

Edmonds-Karp算法是Ford-Fulkerson算法的一种实现方式。该算法使用BFS算法寻找增广路，从而保证每次找到的增广路是最短的。具体来说，Edmonds-Karp算法包括以下步骤：

（1）初始化流量f(u, v)为0；

（2）在残留网络中使用BFS算法寻找一条增广路；

（3）如果找到增广路，则将其上的流量增加到当前流量中；

（4）重复步骤（2）和（3），直到无法找到增广路为止。

5. Dinic算法

Dinic算法是一种更快的最大流算法。该算法使用分层图的思想，将残留网络分层，从而加速寻找增广路的过程。具体来说，Dinic算法包括以下步骤：

（1）初始化流量f(u, v)为0；

（2）构建分层图，将残留网络分层；

（3）在分层图中寻找一条增广路；

（4）如果找到增广路，则将其上的流量增加到当前流量中；

（5）重复步骤（3）和（4），直到无法找到增广路为止。

6. 总结

增广路算法是一种经典的最大流算法，其基本思想是在残留网络中寻找一条增广路，并将其上的流量增加到当前流量中。Ford-Fulkerson算法是增广路算法的基础，而Edmonds-Karp算法和Dinic算法是Ford-Fulkerson算法的两种实现方式。在实际应用中，我们可以根据具体情况选择不同的算法来求解最大流问题。






